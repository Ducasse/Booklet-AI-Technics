!! A-Priori

In order to improve its sales, a small supermarket has collected the receipts from each customer during one month. They want you to analyse those receipts and find products that are often purchased together and propose a set of rules to recommend products to a customer.

For example, you can produce a rule =={wine, ham} => {cheese, bread}==  which means that customers who buy wine and ham, are also likely to buy cheese and bread. So we can recommend these products to them.


!!! What is it?
@sec:APriori-WhatIsIt

A-Priori was originally designed by Agrawal et al. ${cite:Agra94a}$ to discover association rules between items in a large database if sales transactions.

!!! Applications
@sec:APriori-Applications

The applications of A-Priori go far beyond market basket analysis.


!!! Formal Definition
@sec:APriori-Definition

!!!! The Problem of Mining Frequent Itemsets

We are given a set of items called ''item base''

{{{
\[ B = \{ i_1, \dots, i_n \} \]
}}}

And a set of ''transactions'' where each transaction is a set of items from the item base {{{$B$}}}

{{{
\[ T = \{ t_1, \dots, t_m \} \]
\[ t_k \subseteq B \quad \forall t_k \in T \]
}}}

You can think of items as products that are sold at the supermarket, and each transaction as a list of products purchased by one customer (list of products on the receipt).

We use the word ''itemset'' to denote any set of items selected from the item base:

{{{
\[ I \subseteq B \]
}}}

In fact, every transaction is an itemset (an itemset that was purchased) and the item base itself is also an itemset.

The ''cover'' of an itemset {{{$I$}}} in a set of transactions {{{$T$}}} is a subset of transactions that contain all items from this itemset

{{{
\[ K_T(I) = \{ t_k \in T | I \subseteq t_k \} \]
}}}

The ''count'' of an item set {{{$I$}}} in a set of trasactions {{{$T$}}} is the number of transactions in which this itemset appears

{{{
\[ c_T(I) = | K_T(I) | \]
}}}

The ''support'' of an itemset {{{$I$}}} is the relative frequency of this itemset in a set of transactions {{{$T$}}}

{{{
\[ s_T(I) = \frac{c_T(I)}{m} \]
}}}

where {{{$m = |T|$}}} is the total number of transactions. Here are the more intuitive interpretations of the support of an itemset:

- the percentage of transactions that contain this set of items
- the probability that a randomly selected transaction contains this set of items

Given some ''minimum support'' {{{$ s_{min} \in \mathbb{N} $}}}, an itemset {{{$I$}}} is called ''frequent'' if its support {{{$s_T(I)$}}} is greater than or equal to the minimum support. We can define a set of all itemsets that are frequent in a set of transactions {{{$T$}}}:

{{{
\[ F_T(s_{min}) = \{ I \subseteq B | s_T(I) \geq s_{min} \} \]
}}}

The goal of frequent itemset mining is to find the set of all frequent itemsets {{{$F_T(s_{min})$}}} given a set of transactions {{{$T$}}} and a minimum support {{{$s_{min}$}}}.

!!!! Extension of the problem: Association Rules Mining



!!!! Why this is a complicated problem?

The problem described above seems very simple at the first sight. And it is. We can find all frequent itemsets by looping through a set of all possible sets of items taken from {{{$B$}}} and selecting those that are frequent, i.e. itemsets whose support is greater or equal to the minimum support {{{$s_{min}$}}}.

The problem is the algorithmic complexity of this search. The set of itemsets {{{$\mathbb{P}(B)$}}} contains all possible combinations of items from {{{$B$}}}. And its size increases exponentially as you increase the size of {{{$B$}}}.

{{{
\[ |\mathbb{P}(B)| = 2^{|B|} \]
}}}

!!!! The A-Priori Property

The idea behind A-Priori algorithm is based on a simple intuitive property of itemsets: ''if itemset I appears in transactions k times, then there can be no itemset J that contains all elements from I and appers more than k times''.

{{{
\begin{equation}
y = e^x
\end{equation}
}}}

{{{
\begin{equation}
\label{eq}
y = e^x
\end{equation}
}}}

As you can see in Equation *@eq* ...

In other words,

{{{
\[ \forall I \subseteq J \subseteq B\ \colon\quad c_T(I) \geq c_T(J) \]
}}}

This fact will be central to everything what comes next, so we will give a small example to convince you in its validity.

{{{
\begin{example}
You are given stwo itemsets

\begin{align*}
I &= \{ \text{bread}, \text{butter} \} \\
J &= \{ \text{bread}, \text{butter}, \text{salt} \}
\end{align*}

$J$ is a superset of $I$ because it contains all items of $I$ (bread and butter) and some other items (salt).

Suppose that in a database of transactions $T$ itemset $I$ appears 3 times, meaning that there were 3 customers who bought bread and butter.

\[ c_T(I) = 3 \]

Without knowing anything else about the transaction dataset, we can be certain that itemset $J$ could not appear in it more than 3 times. Why? Well, imagine that it's not the case, and the count of $J$ is greater, let's say that it's equal to 5

\[ c_T(J) = 5 \]

This would mean that there were 5 customers, who bought bread, butter, and salt. But then, each one of them bought bread and butter, which means that $c_T(I)$ is at least 5 (it can be greater because there may be customers who bought bread and butter but no salt).
\end{example}
}}}

Therefore, if an itemset is not frequent, then no superset of this itemset can be frequent:

{{{
\[ \forall I \subseteq J \subseteq B\ \colon\quad s_T(I) < s_{min} \Rightarrow s_T(J) < s_{min} \]
}}}

!!!! A-Priori Algorithm

{{{
\begin{algorithm}[H]
 \KwData{Database of transactions $T$ and a support threshold $s_{min}$}
 \KwResult{A set $F_T(s_{min})$ of all frequent itemsets in $T$}
 $L_1 \leftarrow$ \{frequent 1-itemsets\}\\
 \For{($k = 2;\ L_{k-1} \neq \varnothing;\ k++$)}{
 	$C_k \leftarrow$ generate\_candidates($L_{k-1}$)\\
	$L_k \leftarrow \{ I \in C_k | s_T(I) \geq s_{min} \}$
 }
 $F_T(s_{min}) \leftarrow \bigcup_k L_k$
 \caption{A-Priori algorithm}
\end{algorithm}

\begin{algorithm}[H]
 \KwData{A set of frequent ($k-1$)-itemsets $L_{k-1}$}
 \KwResult{A set of candidate $k$-itemsets $C_k$}
 $C_k \leftarrow$ \{\}\\
 \ForAll(\tcp*[f]{join step}){$I \in L_{k-1}$}{
 	\ForAll{$J \in L_{k-1}$}{
		\If{can\_be\_joined($I$, $J$)}{
 			$C_k$.add(join($I$, $J$))
		}
	}
 }
 \ForAll(\tcp*[f]{prune step}){$I \in C_k$}{
 	\ForAll{($k-1$)-subsets $I_{k-1} \subset I$} {
		\If{$I_{k-1} \notin L_{k-1}$}{
			$C_k$.remove($I$)\\
			break
		}
	}
 }
 \caption{Candidate generation for the A-Priori algorithm}
\end{algorithm}
}}}

!!!!! Join step

We select the candidates by joining {{{$L_{k-1}$}}} with itself:

{{{
\[ C_k = L_{k-1} \bowtie L_{k-1} \]
}}}

!!!!! Prune step 

{{{
\begin{tcolorbox}
\paragraph{}
\end{tcolorbox}
}}}

!!! Simple Example
@sec:APriori-SimpleExample

|! TID |! Transaction
| 1 | {eggs, milk, butter}
| 2 | {milk, cereal}
| 3 | {eggs, bacon}
| 4 | {bread, butter}
| 5 | {bread, bacon, eggs}
| 6 | {bread, avocado, butter, bananas}


!!! Designing the API
@sec:APriori-API

[[[
groceries := #( 
  (eggs milk butter)
  (milk cereal)
  (eggs bacon)
  (bread butter)
  (bread bacon eggs)
  (bread avocado butter bananas)).
]]]

[[[
apriori := APriori
  transactions: transactions
  supportThreshold: 1/3
  confidenceThreshold: 1/3.
]]]

[[[
itemsets := apriori frequentItemsets.
rules := apriori associationRules.
]]]

[[[
itemsets first count.
itemsets first support.
]]]

[[[
rules first count.
rules first support.
rules first confidence.
rules first lift.
]]]

!!! Writing tests
@sec:APriori-Tests


!!! Implementation
@sec:APriori-Implementation


!!! Practical Examples
@sec:APriori-PracticalExamples

!!! Recommended Reading
@sec:APriori-RecommendedReading

# ""Fast Algorithm for Mining Association Rules"" by Rakesh Agrawal and Ramakrishnan Srikant ${cite:Agra94a}$
# ""Frequent item set mining"" by Christian Borgelt ${cite:Borg12a}$
# Chapter 6 of ""Data Mining: Concepts and Techniques"" by Jiawei Han, Micheline Kamber, and Jian Pei ${cite:Han11a}$
# Chapter 6 of ""Mining of Massive Datasets"" by Jure Leskovec, Anand Rajaraman, and Jeffrey D. Ullman ${cite:Lesk14a}$