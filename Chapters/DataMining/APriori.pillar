!! A-Priori Algorithm for Mining Frequent Itemsets

Modern retailers collect massive amounts of sales data - the logs of online and offline transactions that are commonly referred to as the ''basket data''. This data allows us to analyse customer behavior and make better management decisions. Which items should we put on sale? How to group items together on the shelves? Which items should we recommend to a specific customer?

Many of these problems can be solved by scanning the database of transactions and identifying ''frequent itemsets'' - the groups of products that are often purchased together. If we know that customers tend to buy bread, butter, and milk together, then we can place them close to each other.

By finding frequent sets of items, we can also produce association rules between products. For example, if we realise that bread, butter, and milk appear together in more than 5\% of transactions, we can go further and calculate that 90\% of customers who purchase bread and butter, also purchase milk. This gives us an association rule {bread, butter} {{{$\Rightarrow$}}} {milk} that can be used to recommend products to customers or sell them together with a discount.

In this chapter, we discuss ''A-Priori'' - a fast and efficient algorithm for mining frequent itemsets and finding association rules.

!!! What is it?
@sec:APriori-WhatIsIt

A-Priori was originally designed by Agrawal et al. ${cite:Agra94a}$ to discover association rules between items in a large database if sales transactions.

!!! Applications
@sec:APriori-Applications

The applications of A-Priori go far beyond market basket analysis.


!!! Formal Definition
@sec:APriori-Definition

Before going further, we must give a formal definition of the problem and the A-Priori algorithm. This section will contain a lot of math, but we believe that going slowly through the math and helping you understand the algorithm in all its details is vital before we start implementing it.

!!!! The Problem of Mining Frequent Itemsets

We are given a set of items called ''item base''

{{{
\[ B = \{ i_1, \dots, i_n \} \]
}}}

And a set of ''transactions'' where each transaction is a set of items from the item base {{{$B$}}}

{{{
\[ T = \{ t_1, \dots, t_m \} \]
\[ t_k \subseteq B \quad \forall t_k \in T \]
}}}

You can think of items as products that are sold at the supermarket, and each transaction as a list of products purchased by one customer (list of products on the receipt).

We use the word ''itemset'' to denote any set of items selected from the item base:

{{{
\[ I \subseteq B \]
}}}

In fact, every transaction is an itemset (a set of items that were purchased by acustomer) and the item base itself is also an itemset (a set of all products in the store).

The ''cover'' of an itemset {{{$I$}}} in a set of transactions {{{$T$}}} is a subset of transactions that contain all items from this itemset

{{{
\[ K_T(I) = \{ t_k \in T | I \subseteq t_k \} \]
}}}

The ''count'' of an item set {{{$I$}}} in a set of trasactions {{{$T$}}} is the number of transactions in which this itemset appears

{{{
\[ \eta_T(I) = | K_T(I) | \]
}}}

The ''support'' of an itemset {{{$I$}}} is the relative frequency of this itemset in a set of transactions {{{$T$}}}

{{{
\[ s_T(I) = \frac{\eta_T(I)}{|T|} \]
}}}

where {{{$|T|$}}} is the total number of transactions. Support of an itemset is the percentage of transactions that contain this all of its items.

Given some ''minimum support'' {{{$ s_{min} \in \mathbb{N} $}}}, an itemset {{{$I$}}} is called ''frequent'' if its support {{{$s_T(I)$}}} is greater than or equal to the minimum support. We can define a set of all itemsets that are frequent in a set of transactions {{{$T$}}}:

{{{
\[ F_T(s_{min}) = \{ I \subseteq B | s_T(I) \geq s_{min} \} \]
}}}

The goal of frequent itemset mining is to find the set of all frequent itemsets {{{$F_T(s_{min})$}}} given a set of transactions {{{$T$}}} and a minimum support {{{$s_{min}$}}}.

!!!! Extension of the problem: Association Rules Mining

Once we have found the set of frequent itemsets {{{$F_T(s_{min})$}}}, we can represent each itemset {{{$Q \in F_T(s_{min})$}}} as a rule in form {{{$I \Rightarrow J$}}} where itemset {{{$I$}}} is a subset of {{{$Q$}}} such that {{{$I \neq \varnothing$}}} and {{{$I \neq Q$}}} and itemset {{{$J$}}} is a complement {{{$Q \setminus I$}}}.

For example, itemset {{{$\{ bread, butter, milk \}$}}} produces 6 association rules:

{{{
\[ \{ bread, butter \} \Rightarrow \{ milk \} \]
\[ \{ bread, milk \} \Rightarrow \{ butter \} \]
\[ \{ butter, milk \} \Rightarrow \{ bread \} \]
\[ \{ bread \} \Rightarrow \{ butter, milk \} \]
\[ \{ butter \} \Rightarrow \{ bread, milk \} \]
\[ \{ milk \} \Rightarrow \{ bread, butter \} \]
}}}

In the context of basket analysis, association rules can be interpreted in the following way:

- {{{$\{ beer, peanuts \} \Rightarrow \{ chips \}$}}} - to every customer who buys beer and peanuts we should also recommend chips.
- {{{$ \{ tea \} \Rightarrow \{ sugar, lemon \} $}}} - to every customer who buys tea we also recommend sugar and lemon.

Every rule {{{$I \Rightarrow J$}}} has count and support in the databese of transactions. They are equal to the count and support of the itemset {{{$Q = I \cup J$}}} from which that rule was generated:

{{{
\[ \eta_T(I \Rightarrow J) = \eta_T(I \cup J) \]
\[ s_T(I \Rightarrow J) = s_T(I \cup J) \]
}}}

It is also a common practice to calculate ''confidence'' {{{$c_T(I \Rightarrow J)$}}}  and ''lift'' {{{$l_T(I \Rightarrow J)$}}} of an association rule and use them to filter rules by specifying minimum confidence {{{$c_{min}$}}} or minimum lift {{{$l_{min}$}}} threshold.

!!!!! Confidence

''Confidence'' of an association rule {{{$I \Rightarrow J$}}} is a conditional probability of itemset {{{$J$}}} appearing in an arbitrary transaction {{{$t \in T$}}} given that the itemset {{{$I$}}} has appeared in that transaction:

{{{
\[ c_T(I \Rightarrow J) = P(J|I) = \frac{\eta_T(I \cup J)}{\eta_T(I)} = \frac{s_T(I \cup J)}{s_T(I)} \]
}}}

In terms of basket anlysis, confidence {{{$c_T(I \Rightarrow J)$}}} tells us what percent of customers who purchased all products from itemset {{{$I$}}} have also purchased all products from itemset {{{$J$}}}.

!!!!! Lift

''Lift'' of an association rule {{{$I \Rightarrow J$}}} is a measure of correlation between {{{$J$}}} and {{{$I$}}}:

{{{
\[ l_T(I \Rightarrow J) = \frac{P(I \cup J)}{P(I)P(J)} = \frac{s_T(I \cup J)}{s_T(I)s_T(J)} \]
}}}

If occurences of {{{$I$}}} and {{{$J$}}} are independent, then {{{$P(I \cup J) = P(I)P(J)$}}} and {{{$l_T(I \Rightarrow J) = 1$}}}. Otherwise, if {{{$l_T(I \Rightarrow J) > 1$}}}, this indicates a positive correlation (people who purchased {{{$I$}}} are likely to also purchase {{{$J$}}}) and if {{{$l_T(I \Rightarrow J) < 1$}}}, then the correlation is negative (people who purchased {{{$I$}}} will most likely not purchase {{{$J$}}}).

Lift {{{$l_T(I \Rightarrow J)$}}} can also be interpreted as a measure of how much the relative frequency of {{{$J$}}} will increase if transactions are restricted to only those that contain {{{$I$}}}:

{{{
\[ l_T(I \Rightarrow J) = \frac{c_T(I \Rightarrow J)}{c_T(\varnothing \Rightarrow J)} = \frac{c_T(I \Rightarrow J)}{s_T(J)} \]
}}}

We invite you to prove that those two definitions of lift are equivalent.

!!!! Why this is a complicated problem?

It may seem that we can find all frequent itemsets in a database of transactions simply by iterating over all possible itemsets and selecting the ones that pass the minimum support threshold.

However, the number of possible itemsets grows very quickly as you increase the size of an item base {{{$B$}}}. Turns out that even for the smallest stores that sell very limited amount of products, a set of all possible combinations of those products will be so big that any analysis on this set becomes infeasible.

Let's take a closer look at this number. If {{{$B$}}} is the item base (for example, a list of all products sold by a supermarket), then the collection of all possible subsets of {{{$B$}}} is called ''powerset'' and denoted {{{$\mathbb{P}(B)$}}}.

{{{
\[ |\mathbb{P}(B)| = 2^{|B|} \]
}}}

+Hasse diagrams showing sets of all possible itemsets as powersets over the itembase B = {a}, B = {a, b}, and B = {a, b, c}. You can see how fast these diagrams are growing.>figures/Powersets.png+

!!!! The A-Priori Property

The idea behind A-Priori algorithm is based on a simple intuitive property of itemsets: ''if itemset I appears in transactions k times, then there can be no itemset J that contains all elements from I and appers more than k times''.

In other words,

{{{
\[ \forall I \subseteq J \subseteq B\ \colon\quad \eta_T(I) \geq \eta_T(J) \]
}}}

This fact will be central to everything what comes next, so we will give a small example to convince you in its validity.

You are given two itemsets

{{{
\begin{align*}
I &= \{ \text{bread}, \text{butter} \} \\
J &= \{ \text{bread}, \text{butter}, \text{salt} \}
\end{align*}
}}}

{{{$J$}}} is a superset of {{{$I$}}} because it contains all items of {{{$I$}}} (bread and butter) and some other items (salt).

Suppose that in a database of transactions {{{$T$}}} itemset {{{$I$}}} appears 3 times, meaning that there were 3 customers who bought bread and butter.

{{{
\[ \eta_T(I) = 3 \]
}}}

Without knowing anything else about the transaction dataset, we can be certain that itemset {{{$J$}}} could not appear in it more than 3 times. Why? Imagine that it's not the case, and the count of {{{$J$}}} is greater, let's say that it's equal to 5

{{{
\[ \eta_T(J) = 5 \]
}}}

This would mean that there were 5 customers, who bought bread, butter, and salt. But then, each one of them bought bread and butter, which means that {{{$\eta_T(I)$}}} is at least 5 (it can be greater because there may be customers who bought bread and butter but no salt).

Therefore, if an itemset is not frequent, then no superset of this itemset can be frequent:

{{{
\[ \forall I \subseteq J \subseteq B\ \colon\quad s_T(I) < s_{min}\ \ \Rightarrow\ \ s_T(J) < s_{min} \]
}}}

+Frequent Itemsets>figures/FrequentItemsets.png+

!!!! A-Priori Algorithm

We start the A-Priori algorithm by what is often called an ''"initialization step"'' - we build a set {{{$L_1$}}} of all frequent itemsets of size 1. We think of every item {{{$i$}}} from the item base {{{$B$}}} as an itemset with 1 element {{{$I = \{ i \}$}}}. Then we select only those itemsets whose support {{{$s_t(I$}}} is greater than or equal to the given minimum support {{{$s_{min}$}}}.

Then we repeat the following two steps with {{{$k = 2, 3, \dots$}}} as long as the set {{{$L_{k-1}$}}} of frequent {{{$(k-1)$}}}-itemsets is not empty:

# ''Candidate generation'': we use the set {{{$L_{k-1}$}}} of frequent {{{$(k-1)$}}}-itemsets to generate {{{$C_k$}}} - a set candidate {{{$k$}}}-itemsets.
# ''Frequent itemset selection'': we construct the set {{{$L_k$}}} of frequent {{{$k$}}}-itemsets by selecting only those candidates from {{{$C_k$}}} that pass the minimem support threshold.

To get a better intuition on the flow of the A-Priori algorithm, take a look on Figure *@figAPriori*. We start with a set of frequent items {{{$L_1$}}}, use it to generate candidates {{{$C_2$}}}, then select frequent pairs {{{$L_2$}}}, and continue this process until we get an empty set {{{$L_k = \varnothing$}}}.

+The flow of A-Priori algorithm>figures/APriori.png|label=figAPriori+

The whole algorithm is formally described with pseudocode as Function *@funAPriori*. The function ==generate_candidates== will be defined in the next section, where we will talk about the process of candidate generation.

{{{
\begin{algorithm}[H]
 \KwData{Database of transactions $T$ and a support threshold $s_{min}$}
 \KwResult{A set $F_T(s_{min})$ of all frequent itemsets in $T$}
 \Fn{apriori(T, $s_{min}$)}{
 	$L_1 \gets$ \{frequent 1-itemsets\}\\
 	\For{($k = 2;\ L_{k-1} \neq \varnothing;\ k++$)}{
 		$C_k \gets$ generate\_candidates($L_{k-1}$)\\
		$L_k \gets \{ I \in C_k | s_T(I) \geq s_{min} \}$
 	}
 	$F_T(s_{min}) \gets \bigcup_k L_k$ \\
	\KwRet $F_T(s_{min})$
 }
 \caption{A-Priori algorithm}
 \label{funAPriori}
\end{algorithm}
}}}

!!!!! Candidate Generation for the A-Priori Algorithm
@sec:APriori-CandidateGeneration

In this section, we will take a closer look at the candidate generation for the A-Priori algorithm. At every iteration, it uses previously generated set {{{$L_{k-1}$}}} of frequent {{{$(k-1)$}}}-itemsets to generate a set {{{$C_k$}}} containing candidate itemsets of size {{{$k$}}}. This is done in two steps:

% I write it in LaTeX because I need to insert equations into the list environment without breaking it into multiple lists
{{{
\begin{enumerate}
\item \textbf{Join step} - we join the set $L_{k-1}$ with itself (this operation is denoted as $L_{k-1} \bowtie L_{k-1}$) according to the rules
\begin{itemize}
\item Every two itemsets $I = \{ i_1, i_2, \dots, i_{k-1} \}$ and $J = \{ j_1, j_2, \dots, j_{k-1} \}$ selected from $L_{k-1}$ can be joined if their first $k-2$ elements are the same and the last element of $I$ is smaller than the last element of $J$ (this ensures that the resulted itemset will be sorted and there will be no duplicate candidates)

\[ (i_1 = j_1) \land (i_2 = j_2) \land \dots \land (i_{k-2} = j_{k-2}) \land (i_{k-1} < j_{k-1}) \]

\item If two itemsets $I$ and $J$ can be joined, we join them into a $k$-itemset $Q$ by taking the first $k-2$ elements that they have in common, and appending to them the last element of $I$ followed by the last element of $J$

\[ Q = \{ i_1, i_2, \dots, i_{k-2}, i_{k-1}, j_{k-1} \} \]
\end{itemize}

\item \textbf{Prune step} - we remove all candidates that have at least one subset of size $k-1$ that is not in $L_{k-1}$.
\end{enumerate}
}}}

You can see the pseudocode of the candidate generation procedure in Function *@funCandidateGeneration*.

{{{
\begin{algorithm}
 \KwData{A set of frequent ($k-1$)-itemsets $L_{k-1}$}
 \KwResult{A set of candidate $k$-itemsets $C_k$}
 \Fn{generate\_candidates($L_{k-1}$)}{
 	$C_k \gets$ \{\}\\
 	\ForAll(\tcp*[f]{join step}){$I \in L_{k-1}$}{
 		\ForAll{$J \in L_{k-1}$}{
			\If{can\_be\_joined($I$, $J$)}{
 				$C_k$.add(join($I$, $J$))
			}
		}
 	}
 	\ForAll(\tcp*[f]{prune step}){$I \in C_k$}{
 		\ForAll{($k-1$)-subsets $I_{k-1} \subset I$} {
			\If{$I_{k-1} \notin L_{k-1}$}{
				$C_k$.remove($I$)\\
				break
			}
		}
 	}
	\KwRet $C_k$
 }
 \Fn{can\_be\_joined(I, J)}{
 	\For{$p \gets 1$ \KwTo $k-2$}{
 		\If{$i_p$ != $j_p$}{
			\KwRet false
		}
	 }
	 \KwRet $i_{k-1} < j_{k-1}$
 }
 \Fn{join(I, J)}{
 	$Q \gets \{\}$ \\
 	\For{$p \gets 1$ \KwTo $k-1$}{
 		Q.add($j_p$)
 	}
 	Q.add($j_{k-1}$) \\
 	\KwRet Q
 }
 \caption{Candidate generation for the A-Priori algorithm}
 \label{funCandidateGeneration}
\end{algorithm}
}}}

!!!! Proving the correctness of candidate generation

It may not be obvious that by joining the set {{{$L_{k-1}$}}} of frequent {{{$(k-1)$}}}-itemsets with itself, using the join operation {{{$L_{k-1} \bowtie L_{k-1}$}}} defined above, we cover all possible itemsets of size {{{$k$}}}. In other words, we need to show that {{{$L_k \subseteq C_k$}}}.

Let's show that an arbitrary frequent {{{$k$}}}-itemset {{{$I_k \in L_k$}}} will be included into {{{$C_k$}}} when we generate {{{$C_k$}}} from {{{$L_{k-1}$}}}:

{{{
\[ I_k = \{ i_1, i_2, \dots, i_k \} \]
}}}

We can extract the following two subsets of size {{{$k-1$}}} from itemset {{{$I_k$}}}:

{{{
\begin{align*}
I_{k-1}^{(1)} &= \{ i_1, i_2, \dots, i_{k-2}, i_{k-1} \} \\
I_{k-1}^{(2)} &= \{ i_1, i_2, \dots, i_{k-2}, i_k \}
\end{align*}
}}}

Based on the A-Priori property, which tells us that every subset of a frequent itemset is also frequent, both {{{$I_{k-1}^{(1)}$}}} and {{{$I_{k-1}^{(2)}$}}} belong to {{{$L_{k-1}$}}} - the set of frequent itemsets of size {{{$k-1$}}}.

{{{
\[ I_{k-1}^{(1)}, I_{k-1}^{(2)} \in L_{k-1} \]
}}}

You might have noticed that we selected {{{$I_{k-1}^{(1)}$}}} and {{{$I_{k-1}^{(2)}$}}} in such way that they satisfy the A-Priori's join condition described in Function *@funJoinCondition*:	

# They share the first {{{$k-2$}}} items
# The last element of {{{$I_{k-1}^{(1)}$}}} is smaller than the last element of {{{$I_{k-1}^{(2)}$}}} because elements of itemset {{{$I_k$}}} are sorted and therefore {{{$i_{k-1} < i_k$}}}

This means that during the join step on set {{{$L_{k-1}$}}}, itemsets {{{$I_{k-1}^{(1)}$}}} and {{{$I_{k-1}^{(2)}$}}} will be joined and therefore:

{{{
\[ I_k \in L_{k-1} \bowtie L_{k-1} \]
}}}

{{{$I_k$}}} will not be removed during the prune step because, as we said before, based on the A-Priori property, all subsets of {{{$I_k$}}} are frequent.

Therefore,

{{{
\[ \forall I_k \in L_k \quad I_k \in C_k \]
}}}

Which means that

{{{
\[ L_k \subseteq C_k \]
}}}

!!! Simple Example
@sec:APriori-SimpleExample

In this section, we will give a simple example of finding frequent itemsets and association rules using A-Priori algorithm.

Given a support threshold {{{$s_{min} = 1/3$}}}, we need to find frequent itemsets in the following database of transactions {{{$T$}}}:

|! TID |! Transaction
| 1 | {eggs, milk, butter}
| 2 | {milk, cereal}
| 3 | {eggs, bacon}
| 4 | {bread, butter}
| 5 | {bread, bacon, eggs}
| 6 | {bread, avocado, butter, bananas}

This means that we have to identify all possible combinations of products that appear in at least 33.33\% of transactions (at least 2 out of 6).

We will then use those frequent itemsets to produce association rules for the two values of minimum confidence threshold: {{{$c_{min} = 2/3$}}} and {{{$c_{min} = 1$}}}.

!!!! Mining Frequent Itemsets

The item base is the set of all products that appear in transactions:

{{{
\[ B = \{ eggs, milk, butter, cereal, bacon, bread, avocado, bananas \} \]
}}}

We start by encoding every product in the item base with an integer number:

|! Product |! Code |! Product |!Code
| eggs | 1 | bacon | 5
| milk | 2 | bread | 6
| butter | 3 | avocado | 7
| cereal | 4 | bananas | 8

This gives us the encoded database of transactions:

|! TID |! Transaction
| 1 | {1, 2, 3}
| 2 | {2, 4}
| 3 | {1, 5}
| 4 | {3, 6}
| 5 | {1, 5, 6}
| 6 | {3, 6, 7, 8}

To initialize the A-Priori algorithm, we need to construct the set {{{$L_1$}}} containing all frequent 1-itemsets. To do that, we first create a set of candidates {{{$C_1$}}} - all items from the encoded item base {{{$B$}}} represented as itemsets of size 1:

{{{
\[ C_1 = \{ \{1\}, \{2\}, \{3\}, \{4\}, \{5\}, \{6\}, \{7\}, \{8\} \} \]
}}}

Now we calculate support of each candidate itemset:

{{{
\begin{center}
\begin{tabular}{ll}
$s_T(\{1\}) = 1/2$ & $s_T(\{5\}) = 1/3$ \\
$s_T(\{2\}) = 1/3$ & $s_T(\{6\}) = 1/2$ \\
$s_T(\{3\}) = 1/2$ & $s_T(\{7\}) = 1/6$ \\
$s_T(\{4\}) = 1/6$ & $s_T(\{8\}) = 1/6$ \\
\end{tabular}
\end{center}
}}}

We can see that itemsets {{{$\{4\}$}}}, {{{$\{7\}$}}}, and {{{$\{8\}$}}} (cereal, avocado, and bananas) did not pass the minimum support threshold of 1/3. They don't appear in transactions often enough to be of any interest to us. And based on the A-Priori property, any set of items that includes at least one of those items, can not have higher support than 1/6. Therefore, items 4, 7, and 8 and all their supersets will be excluded from further analysis.

Other itemsets have passed the support threshold, which means that they are frequent. We collect them into the set of frequent 1-itemsets:

{{{
\[ L_1 = \{ \{1\}, \{2\}, \{3\}, \{5\}, \{6\} \} \]
}}}

Now we generate the candidates of size 2. To do that, we first join the set of frequent 1-itemsets {{{$L_1$}}} with itself according to the rules of a join step described in Section *@sec:APriori-CandidateGeneration*:

{{{
\[ L_1 \bowtie L_1 = \{ \{1,2\}, \{1, 3\}, \{1, 5\}, \{1, 6\}, \{2, 3\}, \{2, 5\}, \{2, 6\}, \{3, 5\}, \{3, 6\}, \{5, 6\} \} \]
}}}

Prune step of the algorithm deletes all itemsets of size {{{$k$}}} that contain at least one subset of size {{{$k-1$}}} which is not in {{{$L_{k-1}$}}}. For {{{$k=2$}}}, all itemsets included in {{{$L_1 \bowtie L_1$}}} are composed only of 1-itemsets taken from {{{$L_1$}}}. So the prune step will not delete any items and the set of candidate itemsets is the same as the result of a join step:

{{{
\[ C_2 = L_1 \bowtie L_1 \]
}}}

Once again, we calculate support of all candidate itemsets:

{{{
\begin{center}
\begin{tabular}{ll}
$s_T(\{1,2\}) = 1/6$ & $s_T(\{2,5\}) = 0$ \\
$s_T(\{1,3\}) = 1/6$ & $s_T(\{2,6\}) = 0$ \\
$s_T(\{1,5\}) = 1/3$ & $s_T(\{3,5\}) = 0$ \\
$s_T(\{1,6\}) = 1/6$ & $s_T(\{3,6\}) = 1/3$ \\
$s_T(\{2,3\}) = 1/6$ & $s_T(\{5,6\}) = 1/6$ \\
\end{tabular}
\end{center}
}}}

Only two itemsets have passed the support thresholds, so only they are selected into the set of all frequent 2-itemsets:

{{{
\[ L_2 = \{ \{1,5\}, \{3,6\} \} \]
}}}

On the next iteration, join step produces an empty set, because the only pair of itemsets from {{{$L_2$}}} does not satisfy the join conditions listed in Section *@sec:APriori-CandidateGeneration* and can not be joined:

{{{
\[ L_2 \bowtie L_2 = \varnothing \]
}}}

This means that the set of candidates {{{$C_3$}}} and the set of frequent itemsets {{{$L_3$}}} are also empty and the algorithm stops here:

{{{
\[ C_3 = L_3 = \varnothing \]
}}}

The set of all frequent itemsets that we were trying to find is the union of {{{$L_1$}}} and {{{$L_2$}}}:

{{{
\[ F_T(s_{min} = 1/3) = L_1 \cup L_2 = \{ \{1\}, \{2\}, \{3\}, \{5\}, \{6\}, \{1,5\}, \{3,6\} \} \]
}}}

We can now decode them using our encoding table. Below, you can find the list of decoded frequent itemsets together with their count and support values (remember that count is support multiplied by the total number of transactions {{{$|T| = 6$}}}). These are all possible sets of products that appear in at least 33.33\% of transactions:

|! Frequent itemset |! Count |! Support
| {eggs} | 3 | 1/2
| {milk} | 2 | 1/3
| {butter} | 3 | 1/2
| {bacon} | 2 | 1/3
| {bread} | 3 | 1/2
| {eggs, bacon} | 2 | 1/3
| {butter, bread} | 2 | 1/3

!!!! Producing Association Rules

We can represent any itemset with at least 2 elements as an association rule. In our case, we only have two itemsets with more than 1 element: {1, 5} and {3, 6}.

The first itemset {1, 5} (eggs and bacon) can be represented as an association rule in two different ways:

{{{
\[ \{ 1 \} \Rightarrow \{ 5 \} \]
\[ \{ 5 \} \Rightarrow \{ 1 \} \]
}}}

First rule means that to every customer who buys item 1 (eggs), we recommend item 5 (bacon). Second rule goes the other way around - to every customer who buys bacon, we recommend eggs. Notice that these are different rules and one of them may be more relevant than the other.

To measure the relevance of these rules, we calculate their confidence:

{{{
\[ c_T(\{ 1 \} \Rightarrow \{ 5 \}) = \frac{s_T(\{ 1, 5 \})}{s_T(\{ 1 \})} = \frac23 \]
\[ c_T(\{ 5 \} \Rightarrow \{ 1 \}) = \frac{s_T(\{ 1, 5 \})}{s_T(\{ 5 \})} = 1 \]
}}}

We can see that 2 out of 3 customers who bought eggs have also bought bacon. And 100\% of customers who bought bacon have also bought eggs.

We can use the value of confidence to calculate the lift of those rules:

{{{
\[ l_T(\{ 1 \} \Rightarrow \{ 5 \}) = \frac{c_T(\{ 1 \} \Rightarrow \{ 5 \})}{s_T(\{ 5 \})} = 2 \]
\[ l_T(\{ 5 \} \Rightarrow \{ 1 \}) = \frac{c_T(\{ 5 \} \Rightarrow \{ 1 \})}{s_T(\{ 1 \})} = 2 \]
}}}

Now let's produce rules from the second itemset {3, 6} (butter and bread):

{{{
\[ \{ 3 \} \Rightarrow \{ 6 \} \]
\[ \{ 6 \} \Rightarrow \{ 3 \} \]
}}}

Again, we calculate the confidence of both rules:

{{{
\[ c_T(\{ 3 \} \Rightarrow \{ 6 \}) = \frac{s_T(\{ 3, 6 \})}{s_T(\{ 3 \})} = \frac23 \]
\[ c_T(\{ 6 \} \Rightarrow \{ 3 \}) = \frac{s_T(\{ 3, 6 \})}{s_T(\{ 6 \})} = \frac23 \]
}}}

And their lift:

{{{
\[ l_T(\{ 3 \} \Rightarrow \{ 6 \}) = \frac{c_T(\{ 3 \} \Rightarrow \{ 6 \})}{s_T(\{ 6 \})} = 4/3 \]
\[ l_T(\{ 6 \} \Rightarrow \{ 3 \}) = \frac{c_T(\{ 6 \} \Rightarrow \{ 3 \})}{s_T(\{ 3 \})} = 4/3 \]
}}}

Now we decode the items and present rules together with their count, support, confidence, and lift. Count and support of each rule is the same as count and support of the frequent itemset from which this rule was extracted.

|! Association rule |! Count |! Support |! Confidence |! Lift
| {{{$ \{ eggs \} \Rightarrow \{ bacon \} $}}} | 2 | 1/3 | 2/3 | 2
| {{{$ \{ bacon \} \Rightarrow \{ eggs \} $}}} | 2 | 1/3 | 1 | 2
| {{{$ \{ butter \} \Rightarrow \{ bread \} $}}} | 2 | 1/3 | 2/3 | 4/3
| {{{$ \{ bread \} \Rightarrow \{ butter \} $}}} | 2 | 1/3 | 2/3 | 4/3

With the minimum confidence threshold {{{$c_{min} = 2/3$}}}, all four rules will be selected. And if we set the confidence threshold {{{$c_{min} = 1$}}}, only the rule {{{$ \{ bacon \} \Rightarrow \{ eggs \} $}}} will pass it.

Here is a way to interpret this: According to our database of transactions, 100\% of customers who bought bacon have also bought eggs. This statement is supported by 33.33\% of transactions.

!!! Implementation
@sec:APriori-Implementation

We implement both itemset and association rules as classes. 

!!!! Itemset class

By definition, itemset is just a set of items. However, the A-Priori algorithm assumes that elements of each itemset are sorted and on multiple occations accesses last (greatest)items from the itemset. This means that the ==Itemset== class can not be implemented on to of a ==Set==. It must be an ordered collection and we find ==Array== to be the best and most efficient class to represent itemsets (we will make sure that there are no duplicates when an itemset is created). We also want each itemset to remember its support and confidence. This way, when the A-Priori algorithm finds the collection of frequent itemsets, each itemset will be able to tell you how many times it appeared in the database of transactions and what is its support:

[[[
Array subclass: #Itemset
	instanceVariableNames: 'count support'
	classVariableNames: ''
	package: 'APriori'
]]]

!!!!! Instance Creation

When the itemset is created, we need to mak sure that it has no duplicates and that the elements are sorted (it is an array that represents an ordered set):

[[[
Itemset class >> withAll: aCollection
	| collectionWithoutDuplicates itemset |
	collectionWithoutDuplicates := aCollection asSet asArray.
	itemset := super withAll: collectionWithoutDuplicates.
	itemset sort.
	^ itemset.
]]]

We extend the ==Collection== class with method ==asItemset== that allows us to quickly create itemsets by converting any kind of collection to ==Itemset== class:

[[[
Collection >> asItemset
	^ Itemset withAll: self
]]]

!!!!! Printing

We want to print an itemset as a set using the notation that is used in most literature: elements separated by commas and enclosed in curly braces: {{{$\{1, 2, 3\}$}}}

[[[
Itemset >> printOn: aStream
	aStream
		nextPut: ${;
		nextPutAll: (', ' join: self);
		nextPut: $}.
]]]

!!!!! Accessors

We add accessors for count and support:

[[[
Itemset >> count
	^ count
]]]
[[[
Itemset >> count: anObject
	count := anObject
]]]
[[[
Itemset >> support
	^ support
]]]
[[[
Itemset >> support: anObject
	support := anObject
]]]

!!!!! Equality

The standard equality operation that ==Itemset== inherits from ==SequenceableCollection== (superclass of ==Array==) checks only if the elements of two given itemsets are equal. But we also want to check if count and support of those itemsets is the same. So we override the equality operation in the following way:

[[[
Itemset >> = anObject
	(super = anObject)
		ifFalse: [ ^ false ].
		
	(self count = anObject count)
		ifFalse: [ ^ false ].
	
	(self support = anObject support)
		ifFalse: [ ^ false ].
		
	^ true
]]]

!!!!! Converting to Array

Sometimes we will only need to compare elements of two itemsets, regardless of their count and support. We can do that by converting itemsets to arrays and then comparing them:

[[[
Itemset >> asArray 
	^ Array withAll: self
]]]

!!!!! Subsets and Supersets

An itemset should be able to tell us if it is a superset of another itemset. This will be useful when we count the occurences of a given itemset in a database of transactions (remember that transactions are itemsets). We will iterate through each transaction and check if it is a superset of a given itemset. So we implement a method that checks if all elements of a given itemset are included into the receiver itemset:

[[[
Itemset >> isSupersetOf: anotherItemset
	^ self includesAll: anotherItemset
]]]

When generating association rules from itemsets, we will need to extract all subsets of a given itemset {{{$I$}}}, without an empty set {{{$\varnothing$}}} and the itemset {{{$I$}}} itself. For example, itemset {{{$\{ 1, 2, 3 \}$}}} has 6 such subsets: {{{$\{1\}$}}}, {{{$\{2\}$}}}, {{{$\{3\}$}}}, {{{$\{1, 2\}$}}}, {{{$\{1, 3\}$}}}, and {{{$\{2, 3\}$}}}. We can find them by generating all possible combinations of elements fom itemset {{{$I$}}} and removing the combination that contains all items ({{{$I$}}} itself):

[[[
Itemset >> allSubsets
	^ (self combinations copyWithout: (self asArray)) collect: #asItemset
]]]

Finally, on the prune step of A-Priori algorithm, we will have to check if all {{{$(k-1)$}}}-subsets of a given candidate {{{$k$}}}-itemset are frequent. To do that, we first need to generate all subsets of a given itemset {{{$I$}}} whose size is one element less than the size of an {{{$I$}}}. We call them largest subsets. For example, largest subsets of itemset {{{$\{ 1, 2, 3 \}$}}} are {{{$\{1, 2\}$}}}, {{{$\{1, 3\}$}}}, and {{{$\{2, 3\}$}}}. We can find them by iteratively removing one element from {{{$I$}}}:

[[[
Itemset >> allLargestSubsets
	^ self collect: [ :item |
		self copyWithout: item ].
]]]

!!!!! Joining Itemsets

As we have discussed in Section *@sec:APriori-Definition*, the join step of A-Priori algorithm joins every two itemsets that saisfy the following condition: {{{$k$}}}-itemset {{{$I$}}} can be joined with {{{$k$}}}-itemset {{{$J$}}} if they share the first {{{$k-1$}}} elements and the last element of {{{$J$}}} is greater than the last element of {{{$I$}}}. To perform this check faster, we don't check if itemsets have same size, because we know that this method will be called by the method ==APriori >> joinFrequentItemsetsOfSize: k== which only iterates over itemsets of size {{{$k$}}}. Notice also that we convert both itemsets to arrays because we only want to compare their elements and not their counts and supports:

[[[
Itemset >> canBeJoinedWith: anotherItemset
	| itemset1WithoutLast itemset2WithoutLast |
	
	itemset1WithoutLast := self asArray copyFrom: 1 to: self size - 1.
	itemset2WithoutLast := anotherItemset asArray copyFrom: 1 to: anotherItemset size - 1.
	
	^ (itemset1WithoutLast = itemset2WithoutLast) and: (self last < anotherItemset last).
]]]

If {{{$k$}}}-itemsets {{{$I$}}} and {{{$J$}}} can be joined, we join them into a new {{{$(k+1)$}}}-itemset which contains the first {{{$k-1$}}} elements which are the same in {{{$I$}}} and {{{$J$}}}, followed by the last element of {{{$I$}}} and then the last element of {{{$J$}}}:

[[[
Itemset >> joinWith: anotherItemset
	| itemsetWithoutLast |
	
	itemsetWithoutLast := self copyFrom: 1 to: self size - 1.
	
	^ (OrderedCollection
		withAll: itemsetWithoutLast)
		add: self last;
		add: anotherItemset last;
		asItemset.
]]]

!!!! AssociationRule class

We implement ==AssociationRule== as a subclass of an ==Association==. Similar to an itemset, an association rule knows its count, support, confidence, and lift.

[[[
Association subclass: #AssociationRule
	instanceVariableNames: 'count support confidence lift'
	classVariableNames: ''
	package: 'APriori'
]]]

!!!!! Instance Creation

To create association rules, we extend ==Association== class with a method ==asAssociationRule== that converts a given association to an association rule:

[[[
Association >> asAssociationRule
	^ AssociationRule key: self key value: self value
]]]

We also add an operator ===>== to the ==Itemset== class that allows us to create association rules simply by combining two itemsets. For example, we can create an itemset {{{$\{a, b, c\} \Rightarrow \{d, e\}$}}} with a simple expression ==#(a b c) asItemset => #(d e) asItemset==.

[[[
Itemset >> => anotherItemset
	^ (self -> anotherItemset) asAssociationRule
]]]

We also add a method to the ==Itemset== class that will allow us to generate all possible association rules from the given itemset. For example, itemset {{{$\{1, 2, 3\}$}}} produces six association rules:

{{{
\[ \{ 1 \} \Rightarrow \{ 2, 3 \}  \]
\[ \{ 2 \} \Rightarrow \{ 1, 3 \}  \]
\[ \{ 3 \} \Rightarrow \{ 1, 2 \}  \]
\[ \{ 1, 2 \} \Rightarrow \{ 3 \}  \]
\[ \{ 1, 3 \} \Rightarrow \{ 2 \}  \]
\[ \{ 2, 3 \} \Rightarrow \{ 1 \}  \]
}}}

[[[
Itemset >> allAssociationRules
	^ self allSubsets collect: [ :eachSubset |
		eachSubset => (self difference: eachSubset) ].
]]]

!!!!! Printing

The following method will print association rules in the form =={1, 2} => {3, 4}==:

[[[
printOn: aStream
	self key printOn: aStream.
	aStream nextPutAll: ' => '.
	self value printOn: aStream.
]]]

!!!!! Accessors

We add accessors for count, support, confidence, and lift of an association rule:

[[[
count
	^ count
]]]
[[[
count: anObject
	count := anObject
]]]
[[[
support
	^ support
]]]
[[[
support: anObject
	support := anObject
]]]
[[[
confidence
	^ confidence
]]]
[[[
confidence: anObject
	confidence := anObject
]]]
[[[
lift
	^ lift
]]]
[[[
lift: anObject
	lift := anObject
]]]

!!!!! Equality

For the same reason that made us override the equality operator of Itemset, we override it for the ==AsociationRule==: the implementation of equality check that it inherits from ==Association== only checks the equality of its key and value itemsets, but we also want to check the equality of count, support, confidence, and lift of the given two itemsets. Notice that the first line will check the equality of objects of ==Association==, it will check the equality of keys and values (both itemsets), thus calling the equality method from ==Itemset== class. And this means that count and support of both key and value itemsets will also be compared.

[[[
= anObject
	(super = anObject)
		ifFalse: [ ^ false ].
		
	^ { self count . self support . self confidence . self lift } = { anObject count . anObject support . anObject confidence . anObject lift }
]]]

!!!!! Converting to Itemset

Association rule can be turned into an itemset by uniting its key and value itemsets. For example, the rule {{{$\{a, b, c\} \Rightarrow \{ d, e \}$}}} can be converted to an itemset {{{$\{ a, b, c, d, e \}$}}}:

[[[
asItemset	
	^ self key union: self value
]]]

!!!! ItemsetEncoder class

[[[
Object subclass: #ItemsetEncoder
	instanceVariableNames: 'vocabulary'
	classVariableNames: ''
	package: 'APriori'
]]]

!!!!! Instance Creation

[[[
new
	self shouldNotImplement
]]]

[[[
basedOn: transactions 
	^ super new initializeTransactions: transactions.
]]]

[[[
initializeTransactions: transactions
	"When encoder is initialized with transactions, it saves unique items into vocabulary. Then it can encode each item by replacing it with its integer index in the vocabulary and decode it by finding the item in the vocabulary by its index"
	vocabulary := (transactions flatCollect: #yourself) asSet asArray.
	^ self
]]]

!!!!! Encoding an Itemset

[[[
encodeItemset: itemset
	"Encode itemset by replacing all its items with their indices in the vocabulary. Returt the encoded itemset with integers. This operation preserves the count and support of an itemset"
	| encodedItemset |
	
	encodedItemset := itemset collect: [ :item |
		vocabulary indexOf: item ].
	
	encodedItemset count: itemset count.
	encodedItemset support: itemset support.
	
	^ encodedItemset
]]]

!!!!! Decoding an Itemset

[[[
decodeItemset: itemset
	"Decode an integer itemset by replacing integers with the corresponding items from the vocabulary (found by index). Return the decoded itemset. This operation preserves the count and support of an itemset"
	| decodedItemset |
	
	decodedItemset := itemset collect: [ :i |
		vocabulary at: i ].
	
	decodedItemset count: itemset count.
	decodedItemset support: itemset support.
	
	^ decodedItemset
]]]

!!!!! Encodeing an AssociationRule

[[[
encodeRule: rule
	"Encode an association rule by encoding its left and right hand side itemsets. Return the encoded rule. This operation preserves the count, support, confidence, and lift of an association rule"
	| encodedRule |
	
	encodedRule := ((self encodeItemset: rule key) => (self encodeItemset: rule value)).
		
	encodedRule
		count: rule count;
		support: rule support;
		confidence: rule confidence;
		lift: rule lift.
		
	^ encodedRule
]]]

!!!!! Decoding an AssociationRule

[[[
decodeRule: rule
	"Decode an association rule by decoding its left and right hand side itemsets. Return the decoded rule. This operation preserves the count, support, confidence, and lift of an association rule"
	| decodedRule |
	
	decodedRule := ((self decodeItemset: rule key) => (self decodeItemset: rule value)).
		
	decodedRule
		count: rule count;
		support: rule support;
		confidence: rule confidence;
		lift: rule lift.
		
	^ decodedRule
]]]

!!!! APriori class

[[[
Object subclass: #APriori
	instanceVariableNames: 'supportThreshold confidenceThreshold frequentItemsets transactions associationRules countDictionary encoder'
	classVariableNames: ''
	package: 'APriori'
]]]

!!!!! Instance Creation

[[[
new 
	self shouldNotImplement 
]]]

[[[
transactions: transactions supportThreshold: aSupportThreshold confidenceThreshold: aConfidenceThreshold
	| transactionsAsItemsets |
	transactionsAsItemsets := transactions collect: #asItemset.
	
	^ super new
		initializeTransactions: transactionsAsItemsets
		supportThreshold: aSupportThreshold
		confidenceThreshold: aConfidenceThreshold
]]]

[[[
initialize 
	super initialize.
	countDictionary := Dictionary new.
]]]

[[[
initializeTransactions: aCollectionOfItemsets supportThreshold: aSupportThreshold confidenceThreshold: aConfidenceThreshold
	"Initialize APriori with a collection of transactions as well as the support and confidence threshols. Create an empty encoder and use it to encode transactions. Encoder will store the encoding dictionary and will be able to decode any itemset or rule that will be generated"
	transactions := aCollectionOfItemsets.
	supportThreshold := aSupportThreshold.
	confidenceThreshold := aConfidenceThreshold.
	
	encoder := ItemsetEncoder basedOn: transactions.
	transactions := encoder encodeItemsets: transactions.
	^ self
]]]

!!!!! Accessors

[[[
confidenceThreshold
	^ confidenceThreshold
]]]

[[[
supportThreshold
	^ supportThreshold
]]]

[[[
transactions
	^ transactions
]]]

[[[
encoder 
	^ encoder
]]]

!!!!! Finding Frequent Itemsets

[[[
frequentItemsets
	"Find frequent itemsets (the ones that pass the support threshold) and save the result. If frequent itemsets have already been fond before, we simply return them without performing the same calculations again. This is especially useful when we find frequent itemsets AND association rules. Because to find association rules we need to find frequent itemsets (which is the most time-consuming operation), so we can use the ones that were found before."
	frequentItemsets ifNil: [ self findFrequentItemsets ].
	^ encoder decodeItemsets: frequentItemsets
]]]

[[[
findFrequentItemsets
	"Find all frequent itemsets - all itemsets that pass the support threshold, meaning that they appear in transactions at least a given number of times. We start by finding frequent itemsets of size 1, then we use them to fing frequent itemsets of size 2, then 3, 4, and so on until we get an empty set."
	| k frequentItemsetsOfSizeK |
	
	k := 1.
	frequentItemsets := Dictionary new.
	
	frequentItemsetsOfSizeK := self findFrequentItemsetsOfSizeOne.
	
	[ frequentItemsetsOfSizeK isEmpty ] whileFalse: [
		frequentItemsets at: k put: frequentItemsetsOfSizeK.
		k := k + 1.
		frequentItemsetsOfSizeK := self findFrequentItemsetsOfSize: k ].
	
	frequentItemsets := frequentItemsets values flatCollect: #yourself
]]]

[[[
findFrequentItemsetsOfSizeOne
	"Find frequent itemsets of size 1 by finding a set of unique items, turning each one of them into an itemset of size 1, and selecting as frequent ones those itemsets that pass the support threshold"
	| uniqueItems itemsets |
	
	uniqueItems := (transactions flatCollect: #yourself) asSet.
	itemsets := uniqueItems collect: [ :item | { item } asItemset ].
	
	itemsets do: [ :itemset | self calculateStatisticsOfItemset: itemset ].
	
	^ itemsets select: [ :itemset |
		itemset support >= self supportThreshold ].
]]]

[[[
findFrequentItemsetsOfSize: k
	"Find frequent itemsets of size k by generating the candidate itemsets (joining a set frequent itemsets of size k-1 with itself) and selecting those that pass the support threshold"
	| candidates |
	candidates := self candidatesOfSize: k.
	
	candidates do: [ :itemset | self calculateStatisticsOfItemset: itemset ].
	
	^ candidates select: [ :itemset |
		itemset support >= self supportThreshold ].
]]]

[[[
joinFrequentItemsetsOfSize: k
	"Join step of candidate generation"
	^ (frequentItemsets at: k) flatCollect: [ :itemset1 |
		(frequentItemsets at: k)
			select: [ :itemset2 | itemset1 canBeJoinedWith: itemset2 ]
			thenCollect: [ :itemset2 | itemset1 joinWith: itemset2 ] ].
]]]

[[[
pruneCandidates: candidates 
	"Prune step of candidate generation"

	^ candidates select: [ :itemset |
		itemset allLargestSubsets allSatisfy: [ :eachSubset |
			(frequentItemsets at: eachSubset size) anySatisfy: [ :aFrequentItemset |
				aFrequentItemset asArray = eachSubset asArray ] ] ].
]]]

!!!!! Finding Association Rules

[[[
associationRules
	"Find association rules if they were not found before. If they were - just return the rules. The algorithm works with integers, so we decode each integer as an item before returning the rules. Association rules are instances of AssociationRule class. They can be reresented as an association of two itemsets:
	
	{a, b, c} => {d, e}
	
	Meanining that customers who purchased a, b, and c, are also likely to purchase d and e."
	
	associationRules ifNil: [ self findAssociationRules ].
	^ encoder decodeRules: associationRules
]]]

[[[
findAssociationRules
	"Find frequent itemsets (or reuse the ones that have already been found), renerate all possible association rules from them, and select those rules that pass the confidence threshold. Save the result inside associationRules variable. This methor will only be executed if associationRules is empty"
	| itemsets |
	itemsets := self frequentItemsets collect: [ :itemset |
		self encoder encodeItemset: itemset ].
	
	associationRules := itemsets flatCollect: [ :itemset |
		itemset allAssociationRules select: [ :rule |
			self calculateStatisticsOfRule: rule.
			rule confidence >= self confidenceThreshold ] ]
]]]

!!!!! Counting Itemsets

[[[
countOfItemset: itemset
	"Return the number of transactions that contain the given itemset. To speed up and not count the same itemset multiple times, we save the result in a dictionary and perform the calculations only for those itemsets that have not been counted before."

	| items |
	"we convert itemset to array because we only need to compare two itemsets by their items, not their counts and supports"
	items := itemset asArray.
	
	(countDictionary includesKey: items) ifFalse: [
		countDictionary at: items put: (self calculateCountOfItemset: itemset) ].
	
	^ countDictionary at: items
]]]

[[[
calculateCountOfItemset: itemset
	"Find the number of transactions that contain all items of the given itemset"
	
	| count |
	count := 0.
	
	transactions do: [ :eachItemset |
		(eachItemset isSupersetOf: itemset)
			ifTrue: [ count := count + 1 ] ].
			
	^ count
]]]

!!!!! Calculating Statistics of Itemsets and Association Rules

[[[
calculateStatisticsOfItemset: itemset
	"Calculate count and support of an itemset:
	
	* count - number of transactions that contain all items of the given itemset 
	* support - probability that a randomly picked transactions contains all items of the given itemset. 
	
	Save both values in the itemset (each itemset should know its count and support)"
	
	itemset count: (self countOfItemset: itemset).
	itemset support: itemset count / transactions size.
]]]

[[[
calculateStatisticsOfRule: rule
	"Calculate count, support, confidence, and lift of an association rule:
	
	* count - number of transactions that contain all items of the itemset constructed by joining itemsets on the right and left hand sides of the rule.
	* support - the probability that a randomly picked transaction contains all items of that itemset.
	* confidence - conditional probability of the rule
	* lift - a correlation measure between the itemsets in the left and right hand sides. It assesses the degree to which the occurence of items in the left itemset 'lifts' (increases) the likelihood of items from the right itemset to appear.
	
	Save all those values in the rule (each rule should know its count, support, confidence, and lift)"
	
	| itemset |
	itemset := rule asItemset.
	self calculateStatisticsOfItemset: itemset.
	self calculateStatisticsOfItemset: rule key.
	self calculateStatisticsOfItemset: rule value.
	
	rule count: itemset count.
	rule support: itemset support.
	rule confidence: itemset count / rule key count.
	rule lift: itemset support / (rule key support * rule value support).
]]]

!!!! AssociationRulesCollection class

[[[
OrderedCollection subclass: #AssociationRulesCollection
	instanceVariableNames: 'count support confidence lift'
	classVariableNames: ''
	package: 'APriori'
]]]

!!!!! GTInspector view

[[[
gtInspectorAssociationRulesIn: composite
	<gtInspectorPresentationOrder: 0>

	^ composite fastTable
		title: 'Association Rules';
		display: [ self ];
		beMultiple;
		enableElementIndex;
		wantsAutomaticRefresh: true;
		column: 'Index' evaluated: [ :rule :idex | idex asString ] width: 50;
		column: 'Antecedent' evaluated: [ :rule | rule key asString ];
		column: '' evaluated: [ :rule | '=>' ] width: 15;
		column: 'Consequent' evaluated: [ :rule | rule value asString ];
		column: 'Count' evaluated: [ :rule | rule count asString ] width: 50;
		column: 'Support' evaluated: [ :rule | rule support asFloat asString ] width: 60;
		column: 'Confidence' evaluated: [ :rule | rule confidence asFloat asString ] width: 55;
		column: 'Lift' evaluated: [ :rule | rule lift asFloat asString ] width: 50;
		send: [ :result | 
			"withSmalltalkSearch;
		showOnly: 50;
		helpMessage: 'Quick selection field. Given your INPUT, it executes: self select: [:each | INPUT ]'."
			result
				ifNil: [ nil ]
				ifNotNil: [ result size = 1
						ifTrue: [ result anyOne ]
						ifFalse: [ self species withAll: result ]
					]
			]
]]]

!!! Writing tests
@sec:APriori-Tests

!!!! APrioriMockTransactions class

[[[
Object subclass: #APrioriMockTransactions
	instanceVariableNames: ''
	classVariableNames: ''
	package: 'APriori-Tests'
]]]

[[[
transactions
	^ #( 
		(eggs milk butter)
		(milk cereal)
		(eggs bacon)
		(bread butter)
		(bread bacon eggs)
		(bread avocado butter bananas))
]]]

!!!! ItemsetTest class

[[[
TestCase subclass: #ItemsetTest
	instanceVariableNames: 'transactions'
	classVariableNames: ''
	package: 'APriori-Tests'
]]]

[[[
setUp 	
	super setUp.
	transactions := APrioriMockTransactions new transactions
]]]

!!!!! Testing Instance Creation

[[[
testItemsetHasNoDuplicates
	| itemset expected actual |
	itemset := #(3 2 2 2 1 2 2 1) asItemset.
	expected := #(1 2 3).
	actual := itemset asArray.
	self assert: actual equals: expected
]]]

[[[
testItemsetIsSorted
	| itemset expected actual |
	
	itemset := #(g d a f h b i e c j) asItemset.
	expected := #(a b c d e f g h i j).
	actual := itemset asArray.
	
	self assert: actual equals: expected
]]]

!!!!! Testing PrintOn

[[[
testPrintOn
	| itemset stream expected actual |
	itemset := #(eggs milk butter) asItemset.
	
	stream := String new writeStream.
	itemset printOn: stream.
	
	expected := '{butter, eggs, milk}'.
	actual := stream contents.
	
	self assert: actual equals: expected.
]]]

!!!!! Testing Conversion

[[[
testAsArray 
	| array itemset expected actual |
	array := #(bread butter avocado).
	itemset := array asItemset.
	actual := itemset asArray.
	expected := array sorted.
	self assert: actual equals: expected.
]]]

!!!!! Testing Subsets and Supersets

[[[
testIsSupersetOf
	| itemset1 itemset2 itemset3 |
	
	itemset1 := #(bread avocado butter bananas) asItemset.
	itemset2 := #(bread butter) asItemset.
	itemset3 := #(bread bacon) asItemset.
	
	self assert: (itemset1 isSupersetOf: itemset2).
	self assert: (itemset1 isSupersetOf: itemset1).
	self deny: (itemset2 isSupersetOf: itemset1).
	self deny: (itemset1 isSupersetOf: itemset3).
]]]

[[[
testAllSubsets
	| itemset expected actual |
	
	itemset := #(bread avocado butter bananas) asItemset.
	
	expected := #(
		(bread)
		(avocado)
		(butter)
		(bananas)
		(bread avocado)
		(bread butter)
		(bread bananas)
		(avocado butter)
		(avocado bananas)
		(butter bananas)
		(bread avocado butter)
		(bread avocado bananas)
		(bread butter bananas)
		(avocado butter bananas)
	) collect: #asItemset.
	
	actual := itemset allSubsets.
	
	"We don't care about the order"
	expected := expected asSet.
	actual := actual asSet.
	
	self assert: actual equals: expected.
]]]

[[[
testAllLargestSubsets
	| itemset expected actual |
	
	itemset := #(bread avocado butter bananas) asItemset.
	
	expected := #(
		(bread avocado butter)
		(bread avocado bananas)
		(bread butter bananas)
		(avocado butter bananas)
	) collect: #asItemset.
	
	actual := itemset allLargestSubsets.
	
	"We don't care about the order"
	expected := expected asSet.
	actual := actual asSet.
	
	self assert: actual equals: expected.
]]]

!!!!! Testing Generation of Association Rules

[[[
testAllAssociationRules
	| itemset expected actual |
	
	itemset := #(bread avocado butter bananas) asItemset.
	
	expected := {
		#(bread) asItemset => #(avocado butter bananas) asItemset . 
		#(avocado) asItemset => #(bread butter bananas) asItemset .
		#(butter) asItemset => #(bread avocado bananas) asItemset .
		#(bananas) asItemset => #(bread avocado butter) asItemset .
		#(bread avocado) asItemset => #(butter bananas) asItemset .
		#(bread butter) asItemset => #(avocado bananas) asItemset .
		#(bread bananas) asItemset => #(avocado butter) asItemset .
		#(avocado butter) asItemset => #(bread bananas) asItemset .
		#(avocado bananas) asItemset => #(bread butter) asItemset .
		#(butter bananas) asItemset => #(bread avocado) asItemset .
		#(bread avocado butter) asItemset => #(bananas) asItemset .
		#(bread avocado bananas) asItemset => #(butter) asItemset .
		#(bread butter bananas) asItemset => #(avocado) asItemset .
		#(avocado butter bananas) asItemset => #(bread) asItemset }.
	
	actual := itemset allAssociationRules.
	
	"We don't care about the order"
	expected := expected asSet.
	actual := actual asSet.
	
	self assert: actual equals: expected.
]]]

!!!!! Testing Joins

[[[
testCanBeJoinedWith
	| itemset1 itemset2 itemset3 |
	
	itemset1 := #(avocado bread butter) asItemset.
	itemset2 := #(avocado bread eggs) asItemset.
	itemset3 := #(bread eggs milk) asItemset.
	
	self assert: (itemset1 canBeJoinedWith: itemset2).
	self deny: (itemset2 canBeJoinedWith: itemset1).
	self deny: (itemset1 canBeJoinedWith: itemset3).
]]]

[[[
testJoinWith
	| itemset1 itemset2 expected actual |
	
	itemset1 := #(avocado bread butter) asItemset.
	itemset2 := #(avocado bread eggs) asItemset.
	
	expected := #(avocado bread butter eggs) asItemset.
	actual := itemset1 joinWith: itemset2.
	
	self assert: actual equals: expected.
]]]

!!!! AssociationRuleTest class

[[[
TestCase subclass: #AssociationRuleTest
	instanceVariableNames: 'transactions'
	classVariableNames: ''
	package: 'APriori-Tests'
]]]

[[[
setUp 
	super setUp.
	transactions := APrioriMockTransactions new transactions.
]]]

!!!!! Testing PrintOn

[[[
testPrintOn
	| itemset1 itemset2 rule stream expected actual |
	
	itemset1 := #(eggs milk butter) asItemset.
	itemset2 := #(avocado bananas) asItemset.
	rule := itemset1 => itemset2.
	
	stream := String new writeStream.
	rule printOn: stream.
	
	expected := '{butter, eggs, milk} => {avocado, bananas}'.
	actual := stream contents.
	
	self assert: actual equals: expected.
]]]

!!!!! Testing Conversion

[[[
testAsItemset
	| itemset1 itemset2 rule expected actual |
	
	itemset1 := #(eggs milk butter) asItemset.
	itemset2 := #(avocado bananas) asItemset.
	rule := itemset1 => itemset2.
	
	expected := #(eggs milk butter avocado bananas) asItemset.
	actual := rule asItemset.
	
	self assert: actual equals: expected.
]]]

!!!! ItemsetEncoderTest class

[[[
TestCase subclass: #ItemsetEncoderTest
	instanceVariableNames: 'transactions encoder'
	classVariableNames: ''
	package: 'APriori-Tests'
]]]

[[[
setUp 
	super setUp.
	transactions := APrioriMockTransactions new transactions.
	encoder := ItemsetEncoder basedOn: transactions.
]]]

!!!!! Testing Encoded and Decoded Itemsets


[[[
testEncodeItemset
	| itemset expected actual |
	itemset := #(bread butter) asItemset.
	expected := #(2 5) asItemset.
	actual := encoder encodeItemset: itemset.
	self assert: actual equals: expected.
]]]

[[[
testDecodeItemset
	| itemset expected actual |
	itemset := #(2 5) asItemset.
	expected := #(bread butter) asItemset.
	actual := encoder decodeItemset: itemset.
	self assert: actual equals: expected.
]]]

!!!!! Testing Count and Support of Endoded and Decoded Itemsets

[[[
testEncodeItemsetCountSupport
	| itemset encoded |
	
	itemset := #(bread butter) asItemset
		count: 10;
		support: 0.1;
		yourself.
	
	encoded := encoder encodeItemset: itemset.
	
	self assert: encoded count equals: 10.
	self assert: encoded support equals: 0.1.
]]]

[[[
testDecodeItemsetCountSupport
	| itemset decoded |
	
	itemset := #(2 5) asItemset
		count: 10;
		support: 0.1;
		yourself.
	
	decoded := encoder decodeItemset: itemset.
	
	self assert: decoded count equals: 10.
	self assert: decoded support equals: 0.1.
]]]

!!!!! Testing Encoded and Decoded Association Rules

[[[
testEncodeRule
	| rule expected actual |
	rule := #(bread) asItemset => #(butter) asItemset.
	expected := #(2) asItemset => #(5) asItemset.
	actual := encoder encodeRule: rule.
	self assert: actual equals: expected.
]]]

[[[
testDecodeRule
	| rule expected actual |
	rule := #(2) asItemset => #(5) asItemset.
	expected := #(bread) asItemset => #(butter) asItemset.
	actual := encoder decodeRule: rule.
	self assert: actual equals: expected.
]]]

!!!!! Testing Count, Support, Confidence, and Lift of Endoded and Decoded Association Rules

[[[
testEncodeRuleCountSupportConfidenceLift
	| rule encoded |
	
	rule := (#(bread) asItemset => #(butter) asItemset)
		count: 10;
		support: 0.1;
		confidence: 0.5;
		lift: 2;
		yourself.
	
	encoded := encoder encodeRule: rule.
	
	self assert: encoded count equals: 10.
	self assert: encoded support equals: 0.1.
	self assert: encoded confidence equals: 0.5.
	self assert: encoded lift equals: 2.
]]]

[[[
testDecodeRuleCountSupportConfidenceLift
	| rule decoded |
	
	rule := (#(2) asItemset => #(5) asItemset)
		count: 10;
		support: 0.1;
		confidence: 0.5;
		lift: 2;
		yourself.
	
	decoded := encoder decodeRule: rule.
	
	self assert: decoded count equals: 10.
	self assert: decoded support equals: 0.1.
	self assert: decoded confidence equals: 0.5.
	self assert: decoded lift equals: 2.
]]]

!!!!! Testing Count and Support of Key and Value Itemsets of the Endoded and Decoded Association Rules

[[[
testEncodeRuleKeyCountSupport
	| itemset1 itemset2 rule encoded |
	
	itemset1 := #(bread) asItemset
		count: 10;
		support: 0.1;
		yourself.
		
	itemset2 := #(butter) asItemset.
	rule := itemset1 => itemset2.
	
	encoded := encoder encodeRule: rule.
	
	self assert: encoded key count equals: 10.
	self assert: encoded key support equals: 0.1.
]]]

[[[
testEncodeRuleValueCountSupport
	| itemset1 itemset2 rule encoded |
	
	itemset1 := #(bread) asItemset.
		
	itemset2 := #(butter) asItemset
		count: 10;
		support: 0.1;
		yourself.
		
	rule := itemset1 => itemset2.
	
	encoded := encoder encodeRule: rule.
	
	self assert: encoded value count equals: 10.
	self assert: encoded value support equals: 0.1.
]]]

[[[
testDecodeRuleKeyCountSupport
	| itemset1 itemset2 rule decoded |
	
	itemset1 := #(2) asItemset
		count: 10;
		support: 0.1;
		yourself.
		
	itemset2 := #(5) asItemset.
	rule := itemset1 => itemset2.
	
	decoded := encoder decodeRule: rule.
	
	self assert: decoded key count equals: 10.
	self assert: decoded key support equals: 0.1.
]]]

[[[
testDecodeRuleValueCountSupport
	| itemset1 itemset2 rule decoded |
	
	itemset1 := #(2) asItemset.
		
	itemset2 := #(5) asItemset
		count: 10;
		support: 0.1;
		yourself.
		
	rule := itemset1 => itemset2.
	
	decoded := encoder decodeRule: rule.
	
	self assert: decoded value count equals: 10.
	self assert: decoded value support equals: 0.1.
]]]

!!!! APrioriTest class

[[[
TestCase subclass: #APrioriTest
	instanceVariableNames: 'transactions apriori'
	classVariableNames: ''
	package: 'APriori-Tests'
]]]

[[[
setUp 
	super setUp.
	transactions := APrioriMockTransactions new transactions.
	
	apriori := APriori
		transactions: transactions
		supportThreshold: 2/6
		confidenceThreshold: 2/6.
]]]

!!!!! Testing Count and Support of an Itemset

[[[
testCalculateCountOfItemset
	| itemset expected actual |
	
	itemset := #(bread butter) asItemset.
	itemset := apriori encoder encodeItemset: itemset.
	
	apriori calculateStatisticsOfItemset: itemset.
	
	expected := 2.
	actual := itemset count.
	
	self assert: actual equals: expected.
]]]

[[[
testCalculateSupportOfItemset
	| itemset expected actual |
	
	itemset := #(bread butter) asItemset.
	itemset := apriori encoder encodeItemset: itemset.
	
	apriori calculateStatisticsOfItemset: itemset.
	
	expected := 1/3.
	actual := itemset support.
	
	self assert: actual equals: expected.
]]]

!!!!! Testing Count, Support, Confidence, and Lift of an Association Rule

[[[
testCalculateCountOfRule
	| rule expected actual |
	
	rule := #(bread) asItemset => #(butter) asItemset.
	rule := apriori encoder encodeRule: rule.
	
	apriori calculateStatisticsOfRule: rule.
	
	expected := 2.
	actual := rule count.
	
	self assert: actual equals: expected.
]]]

[[[
testCalculateSupportOfRule
	| rule expected actual |
	
	rule := #(bread) asItemset => #(butter) asItemset.
	rule := apriori encoder encodeRule: rule.
	
	apriori calculateStatisticsOfRule: rule.
	
	expected := 1/3.
	actual := rule support.
	
	self assert: actual equals: expected.
]]]

[[[
testCalculateConfidenceOfRule
	| rule expected actual |
	
	rule := #(bread) asItemset => #(butter) asItemset.
	rule := apriori encoder encodeRule: rule.
	
	apriori calculateStatisticsOfRule: rule.
	
	expected := 2/3.
	actual := rule confidence.
	
	self assert: actual equals: expected.
]]]

[[[
testCalculateLiftOfRule
	| rule expected actual |
	
	rule := #(bread) asItemset => #(butter) asItemset.
	rule := apriori encoder encodeRule: rule.
	
	apriori calculateStatisticsOfRule: rule.
	
	expected := 4/3.
	actual := rule lift.
	
	self assert: actual equals: expected.
]]]

!!!!! Testing Count and Support of Key and Value of an Association Rule

[[[
testCalculateKeyCountOfRule
	| rule expected actual |
	
	rule := #(bread) asItemset => #(butter) asItemset.
	rule := apriori encoder encodeRule: rule.
	
	apriori calculateStatisticsOfRule: rule.
	
	expected := 3.
	actual := rule key count.
	
	self assert: actual equals: expected.
]]]

[[[
testCalculateKeySupportOfRule
	| rule expected actual |
	
	rule := #(bread) asItemset => #(butter) asItemset.
	rule := apriori encoder encodeRule: rule.
	
	apriori calculateStatisticsOfRule: rule.
	
	expected := 1/2.
	actual := rule key support.
	
	self assert: actual equals: expected.
]]]

[[[
testCalculateValueCountOfRule
	| rule expected actual |
	
	rule := #(bread) asItemset => #(butter) asItemset.
	rule := apriori encoder encodeRule: rule.
	
	apriori calculateStatisticsOfRule: rule.
	
	expected := 3.
	actual := rule value count.
	
	self assert: actual equals: expected.
]]]

[[[
testCalculateValueSupportOfRule
	| rule expected actual |
	
	rule := #(bread) asItemset => #(butter) asItemset.
	rule := apriori encoder encodeRule: rule.
	
	apriori calculateStatisticsOfRule: rule.
	
	expected := 1/2.
	actual := rule value support.
	
	self assert: actual equals: expected.
]]]

!!!!! Testing Frequent Itemsets

[[[
testFrequentItemsets
	| expected actual |
	
	expected := {
		#(eggs) asItemset
			count: 3;
			support: 1/2;
			yourself .
			
		#(milk) asItemset
			count: 2;
			support: 1/3;
			yourself .
			
		#(butter) asItemset
			count: 3;
			support: 1/2;
			yourself .
			
		#(bacon) asItemset
			count: 2;
			support: 1/3;
			yourself .
			
		#(bread) asItemset
			count: 3;
			support: 1/2;
			yourself .
			
		#(eggs bacon) asItemset
			count: 2;
			support: 1/3;
			yourself .
	
		#(bread butter) asItemset
			count: 2;
			support: 1/3;
			yourself .
	}.
		
	actual := apriori frequentItemsets.
	
	"We don't care about the order"
	expected := expected asSet.
	actual := actual asSet.
	
	self assert: actual equals: expected.
]]]

!!!!! Testing Association Rules

[[[
testAssociationRules
	| itemsetBread itemsetButter itemsetBacon itemsetEggs rule1 rule2 rule3 rule4 expected actual |
	
	itemsetBread := #(bread) asItemset
		count: 3;
		support: 1/2;
		yourself.
		
	itemsetButter := #(butter) asItemset
		count: 3;
		support: 1/2;
		yourself.
		
	itemsetBacon := #(bacon) asItemset 
		count: 2;
		support: 1/3;
		yourself.
		
	itemsetEggs := #(eggs) asItemset
		count: 3;
		support: 1/2;
		yourself.
		
	rule1 := (itemsetBread => itemsetButter)
		count: 2;
		support: 1/3;
		confidence: 2/3;
		lift: 4/3;
		yourself.
		
	rule2 := (itemsetButter => itemsetBread)
		count: 2;
		support: 1/3;
		confidence: 2/3;
		lift: 4/3;
		yourself.
		
	rule3 := (itemsetBacon => itemsetEggs)
		count: 2;
		support: 1/3;
		confidence: 1;
		lift: 2;
		yourself.
		
	rule4 := (itemsetEggs => itemsetBacon)
		count: 2;
		support: 1/3;
		confidence: 2/3;
		lift: 2;
		yourself.
		
	expected := { rule1 . rule2 . rule3 . rule4 }.
	actual := apriori associationRules.
	
	"We don't care about the order"
	expected := expected asSet.
	actual := actual asSet.
	
	self assert: actual equals: expected.
]]]

!!! Practical Examples
@sec:APriori-PracticalExamples

!!! Recommended Reading
@sec:APriori-RecommendedReading

# ""Fast Algorithm for Mining Association Rules"" by Rakesh Agrawal and Ramakrishnan Srikant ${cite:Agra94a}$
# ""Frequent item set mining"" by Christian Borgelt ${cite:Borg12a}$
# Chapter 6 of ""Data Mining: Concepts and Techniques"" by Jiawei Han, Micheline Kamber, and Jian Pei ${cite:Han11a}$
# Chapter 6 of ""Mining of Massive Datasets"" by Jure Leskovec, Anand Rajaraman, and Jeffrey D. Ullman ${cite:Lesk14a}$

!!! List of notations used in this chapter
@sec:APriori-Notation

|! Symbol |! Interpretation
| {{{$i_1, \dots, i_k$}}} | items (products)
| {{{$t_1, \dots, t_m$}}} | transactions
| {{{$I, J, Q$}}} | itemsets
| {{{$I_k, J_k, Q_k$}}} | itemsets of size k or k-itemsets
| {{{$I \Rightarrow J$}}} | association rule
| {{{$B$}}} | item base
| {{{$T$}}} | database of transactions
| {{{$K_T(I)$}}} | cover of itemset {{{$I$}}} in a database of transactions {{{$T$}}}
| {{{$\eta_T(I)$}}} | count of itemset {{{$I$}}} in a database of transactions {{{$T$}}}
| {{{$s_T(I)$}}} | support of itemset {{{$I$}}} in a database of transactions {{{$T$}}}
| {{{$c_T(I \Rightarrow J)$}}} | confidence of association rule {{{$I \Rightarrow J$}}} in a database of transactions {{{$T$}}}
| {{{$l_T(I \Rightarrow J)$}}} | lift of association rule {{{$I \Rightarrow J$}}} in a database of transactions {{{$T$}}}
| {{{$s_{min}$}}} | minimum support threshold
| {{{$c_{min}$}}} | minimum confidence threshold
| {{{$l_{min}$}}} | minimum lift threshold
| {{{$C_k$}}} | set of candidate itemsets of size k
| {{{$L_k$}}} | set of frequent itemsets of size k
| {{{$L_k \bowtie L_k$}}} | set {{{$L_k$}}} joined with itself according to the rules defined in this chapter
| {{{$F_T(s_{min})$}}} | set of all frequent itemsets in the database of transactions {{{$T$}}} with minimum support {{{$s_{min}$}}}
| {{{$\mathbb{P}(B)$}}} | powerset of {{{B}}}
| {{{$P(J \vert I)$}}} | conditional probability of {{{$J$}}} given {{{$I$}}}
